# Final

## Part 1

Consider the topology below where each circle represents a router executing the OSPF link-state routing protocol. The dashed lines represent links to other routers that are not shown in the figure. Consider the reliable flooding algorithm is disseminating a link-state packet P. Suppose P arrives first in router A. Discuss:

---

Assuming that the links are of similar lengths.

1. A -> X, B, Y
2. â€¦
    - X -> C
    - B -> C
    - Y -> C
3. C -> (X, B, Y), D

---

1. How many times is P received by router B?

    1 time, if the LSP from B to C arrive before the LSPs from X and Y to C;
    2 times, otherwise.
    Alternatively, 1 time for sure, if the protocol specifies a waiting time
    long enough before forwarding LSPs.
2. How many times is P received by router C?

    3 times.
3. How many times is P received by router D?

    1 time.
4. Would any of these answers change if there was a link between routers X and B?

    The first answer might change.

    If so, how would they change?

    B would receive P one more time if the LSP from A to X arrive before
    the LSP from B to X arrive, which is probable given our assumption.

## Part 2

Answer the following questions about AI/MD (additive-increase multiplicative-decrease):

1. How does AI/MD operate?

    According to the lecture on Congestion Control and my notes:
    - Maintains congestion window `cwnd`.
    - AI: After `cwnd` bytes are delivered without drops,
        increase `cwnd` by `packet_size`.
    - MD: When a packet is dropped, assign `max(cwnd / 2, packet_size)` to
        `cwnd`.
2. What are some ideas behind additive-increase of the congestion window?

    - Limit the total size of packets in-flight.
    - Conservative speed-up.
    - Avoid suddenly having a large `cwnd` and causing congestion.
3. What are some ideas behind multiplicative-decrease of the congestion window?

    According to 6.3.1 in the book.
    - Aggressive back-off.
    - Drops are probably caused by a `cwnd` that is way too large.
    - Avoid worse congestion considering that the dropped packets would be
        retransmitted.

## Part 3

Consider the data dump below, capturing a Web request generated by a Web browser. The \<cr> and \<lf> tokens are used to capture the carriage-return and newline characters, also commonly denoted as \r and \n in code. In other words, consider that the carriage-return and newline characters appear whenever the \<cr> and \<lf> tokens appear in the data dump.

```
GET /cursos/unidades-academicas HTTP/1.1<cr><lf>
Host: ufmg.br<cr><lf>
User-Agent: Mozilla/5.0 (Windows;U; Windows NT 5.1; en-US; rv:1.7.2) Gecko/20040804 Netscape/7.2 (ax)<cr><lf>
Accept-Language: en-us,en<cr><lf>
Accept-Encoding: zip,deflate<cr><lf>
Accept-Charset: ISO-8859-1,utf-8<cr><lf>
Keep-Alive: 300<cr><lf>
Connection:keep-alive<cr><lf>
<cr><lf>
```

Answer the following questions:

1. What is the complete URL of the object requested by the Web browser?

    <http://ufmg.br/cursos/unidades-academicas>.
2. Which version of the HTTP protocol is being used?

    Version 1.1.
3. Discuss what will happen from the point of view of the TCP and HTTP protocols if the user clicks on a link and a new Web request is sent to the same server by the browser.

    TCP: The user's browser sends a series of new packet to the same server
    using the old connection.

    HTTP: The user sends a new HTTP request to the same host with a different
    URI using the old HTTP connection that is `keep-alive`.

## Part 4

Suppose you click on a link in your browser to access a Web page. Consider the following scenario:

- The IP address associated to the URL is not in your local resolver's cache.

- The round-trip time (RTT) between your computer and the local resolver is 4ms.

- Your local resolver will need to contact 2 additional resolvers, and that the RTT between your local resolver to each additional resolver is 6ms.

- The Web page associated to the link you clicked contains only a single object which consists of a small HTML file.

- The RTT between your machine and the Web server is 8ms.

- The RTT between the local resolver and the Web server is 12ms.

- Transmission time is zero (i.e., there is infinite bandwidth).

- Compute time to serve any request is zero (i.e., requests are answered instantaneously).

Answer the following questions:

1. Describe the sequence of messages that will be exchanged by the client, Web server, and all DNS resolvers. Describe the source, destination, and content of each message. Define the order in which messages are sent.

    Assuming each DNS request only take one round trip.

    1. client -> local resolver:\
        ask to resolve the domain name (4ms first part).
    2. local resolver -> additional resolver 1:\
        ask to resolve the domain name (6ms first part).
    3. additional resolver 1 -> local resolver:\
        respond with address to additional resolver 2 (6ms second part).
    4. local resolver -> additional resolver 2:\
        ask to resolve the domain name (6ms first part).
    5. additional resolver -> local resolver:\
        respond with address to domain name (6ms second part).
    6. local resolver -> client:\
        respond with address to domain name (4ms second part).
    7. client -> Web server:\
        TCP request to establish a connection (start of TCP handshake,
        8ms first part).
    8. Web server -> client:\
        TCP response to establish a connection (8ms second part).
    9. client -> Web server:\
        ACK to the TCP response (end of TCP handshake).
    10. client -> Web server:\
        HTTP request to the URI specified in the link (8ms first part).
    11. Web server -> client:\
        HTTP response with the small HTML file (8ms second part).
2. How long will it take for the client to receive the HTML file?

    4 + 6 + 6 + 8 + 8 = 32 (ms)

## Part 5

A SYN flood attack is a denial of service attack against TCP servers that may exhaust resources (such as RAM) available on the server and compromise its ability to service legitimate connections. A TCP SYN flood attack is perpetrated by sending a very large number of connection establishment requests with the SYN flag set, but never finishing the TCP three-way handshake by never sending an ACK packet to the server.

Explain why a SYN flood attack works: What resources are used and exhausted by the TCP server under attack? (Consider that the TCP server does not employ any countermeasures against the SYN flood attack.)

---

A request with the SYN flag set initiates a TCP three-way handshake,
so the server should respond with SYN/ACK and wait for the ACK from client
that completes the handshake.

The attacker client never sends the ACK back and the server would just wait
until it times out.
Meanwhile, the server stores the information about the handshake initiation,
almost definitely in its RAM,
probably in some forms of threads which requires a decent amount of allocation.

By sending a massive amount of SYN,
the attacker clients force the server to store a large amount of handshake
initiation state presumably in its RAM before each of them times out,
resulting it to allocate more and more memory,
and thus exhausting its RAM.

## Part 6

A stateless firewall can filter a packet based on the network interfaces on which it would be forwarded.

- False.

    As 3.5.1 in the book suggests,
    network interfaces require memory to operate.
    Also, forwarding tables change and thus are stateful.

A stateless firewall can filter packets based on link utilization.

- False.

    Link utilization changes and thus is stateful.

## Part 7

We can send an e-mail message to <user1@example.com>, <user2@example.com>, and <user3@example.com> in a single SMTP connection.

- True.

    Emails can have multiple recipients.
    One can also send multiple emails in one SMTP connection.

High search overhead is a limitation of unstructured peer-to-peer networks.

- True.

    According to the Peer-to-peer Networks (P2P) lecture.

With ephemeral connections between browser and server as in HTTP 1.0, it is possible that a single TCP segment carries two HTTP responses from the server to the client.

- False.

    HTTP 1.0 specifies that the server closes the TCP connection after each
    response.
